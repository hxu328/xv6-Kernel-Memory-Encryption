# xv6-Kernel-Memory-Encryption
To simplify this project, we approximate the benefits of encryption by flipping all bits in a page (i.e., xor every bit with 1 or just use ~);  actually performing encryption would require more computation and recording a corresponding key, but those are not relevant to this project.

## User-level Memory Encryption
1. Page Encryption: int mencrypt(char *virtual_addr, int len) The virtual page associated with the parameter virtual_addr will be the starting virtual page. The parameter len specifies how many pages will be encrypted. The system call will not assume virtual_addr is always page-aligned. A successful call to mencrypt will encrypt the virtual addresses ranging from [PGROUNDDOWN(virtual_addr), PGROUNDDOWN(virtual_addr) + len * PGSIZE] and returns 0. For instance, suppose the page size is 4KB, a successful call to mencrypt(0x3000, 2)  will encrypt the virtual addresses in the range [0x3000, 0x5000]. A call to mencrypt(0x3050, 2) will do the same.
2. Page Decryption: - An encrypted page must be decrypted whenever it is accessed, so the kernel must catch a user's access to any encrypted page.  To do this, xv6-p4 modifies the kernel to use one bit (called PTE_E) in page table entries (PTEs) to record whether or not the corresponding page is currently encrypted (fortunately, there are plenty of unused bits in the current PTEs). It sets this bit to 1 in the PTEs when the corresponding pages are encrypted. - Secondly, recall xv6 is running on emulated x86 hardware, so every time a user process tries to access some virtual address, the hardware walks the page tables to find the PTE and grab the corresponding physical address translation. The OS usually isn't involved when doing the address translation -- except when there is a page fault (i.e., PTE_P bit is not set). So, the trick is, xv6-p4 will clear the PTE_P bit when it sets the PTE_E bit.  Then, when a user process tries to access this page, a page fault will be triggered, and it looks at the faulting address; if the faulting address occurred for a page where PTE_P was cleared and PTE_E was set, it knows to decrypt the page, reset the appropriate bits in the PTE, and return from the trap.

## Main Idea: Kernel Memory Encryption Pager
In this project, we will explore the idea of letting the kernel manage page encryption and decryption. Encrypting pages with the mencrypt interface as it stands would require modifying each application, and require each application to know which pages are worth encrypting.  You will modify the system to keep a fixed number of recently-accessed pages for each process stored in cleartext (decrypted). The idea is to minimize the number of page decryptions (and re-encryptions) by keeping each process's working set in cleartext.
Let the constant N be the number of recently accessed pages that should be tracked for each process (and kept decrypted).  Add the following line to param.h which defines N:
#define CLOCKSIZE 8   // CLOCKSIZE represents N above
When an encrypted page is accessed by the user, a page fault should be triggered. If the number of currently decrypted pages of the calling process is smaller than N, then this page should be decrypted and pushed to the tail of a queue (see details in the next paragraph). If the calling process already has N decrypted pages, we need to find a victim page to replace.
In order to decide the victim page, you will implement a clock (also called FIFO-with-second-chance) algorithm. To implement this algorithm, you need to (statically) allocate a clock queue for each process. The clock queue is a queue-like structure storing all the virtual pages that are currently decrypted. The other essential part of a clock algorithm is a reference bit that gets set to 1 every time a page is accessed. Luckily for us, x86 hardware sets the sixth bit (or fifth if you start from 0. 0x020, to be precise) of the corresponding page table entry to 1 every time a page is accessed. Let's call this bit PTE_A. See Figure 2-1 (Page 30) in the xv6 reference book (Links to an external site.) for more details. The hardware-managed access bit should be cleared by the kernel (in software) at the appropriate time and have the hardware automatically set the bit when that page is accessed. 
